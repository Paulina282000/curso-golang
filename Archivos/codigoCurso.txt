// Go Basics Example
// Este archivo muestra ejemplos ordenados de sintaxis básica en Go: variables, tipos, control de flujo, colecciones y funciones.

package main

import (
	"fmt"
)

func main2() {
	// ----- Salida inicial -----
	fmt.Println("Hello, World desde Go!")

	// ----- Variables y Constantes -----
	var nombre string = "Juan" // Declaración explícita
	apellido := "Perez"        // Declaración implícita
	edad := 25                 // Inferencia de tipo

	const (
		id = 1234567890 // Constante entera
		pi = 3.14159    // Constante float
	)
	fmt.Println("Nombre:", nombre, "Apellido:", apellido, "Edad:", edad)
	fmt.Println("ID:", id, "Pi:", pi)

	// ----- Tipos Numéricos -----
	var (
		entero8  uint8   = 255
		entero16 uint16  = 65535
		f32      float32 = 2.5
		f64      float64 = 2.5
	)
	fmt.Println(entero8, entero16, f32, f64)

	// ----- Otros Tipos -----
	cadena := "Hola, mundo!"
	booleano := true
	fmt.Println("Cadena:", cadena, "Booleano:", booleano)

	// ----- Operadores Aritméticos -----
	num1, num2 := 10, 20
	fmt.Println("Suma:", num1+num2)
	fmt.Println("Resta:", num1-num2)
	fmt.Println("Multiplicación:", num1*num2)
	fmt.Println("División:", num1/num2)
	fmt.Println("Módulo:", num1%num2)

	// ----- Operadores Lógicos -----
	adulto, permiso := true, false
	fmt.Println("Puede entrar?", adulto && permiso)
	fmt.Println("Puede salir?", adulto || permiso)
	fmt.Println("No puede salir?", !adulto)

	// ----- Control de Flujo -----
	if edad >= 18 {
		fmt.Println("Mayor de edad")
	} else {
		fmt.Println("Menor de edad")
	}

	dia := 10
	switch dia {
	case 1:
		fmt.Println("Lunes")
	case 2:
		fmt.Println("Martes")
	default:
		fmt.Println("Día inválido")
	}

	// ----- Bucles -----
	for i := 0; i <= 5; i++ {
		fmt.Println("i =", i)
	}

	// ----- Arrays -----
	arrNombres := [3]string{"Juan", "Maria", "Pedro"}
	fmt.Println("Array:", arrNombres)

	// ----- Slices -----
	sliceFrutas := []string{"Manzana", "Pera", "Naranja"}
	sliceFrutas = append(sliceFrutas, "Uva")
	fmt.Println("Slice:", sliceFrutas)

	// ----- Maps -----
	edades := map[string]int{"Juan": 20, "Maria": 25, "Pedro": 30}
	fmt.Println("Map:", edades)

	// ----- Range en Colecciones -----
	numeros := []int{10, 20, 30, 40, 50}
	for idx, num := range numeros {
		fmt.Println(idx, num)
	}

	capitales := map[string]string{"Argentina": "Buenos Aires", "Brasil": "Brasilia", "Chile": "Santiago"}
	for pais, capital := range capitales {
		fmt.Println(pais, "->", capital)
	}

	// ----- Funciones -----
	suma, resta := sumarYRestar(10, 20)
	fmt.Println("Suma:", suma, "Resta:", resta)
}

// sumarYRestar devuelve la suma y resta de dos enteros
func sumarYRestar(a, b int) (int, int) {
	return a + b, a - b
}
multiplicar := func(a, b int) int {
		return a * b
	}

	resultado := multiplicar(2, 3)
	fmt.Println("El resultado de la multiplicacion es:", resultado)

	//crear un funcion e imprimirla

	doble := func(n int) int {
		return n * 2
	}(5) //aca se esta ejecutando la funcion anonima y se esta imprimiendo el resultado

	fmt.Println("El doble de es:", doble)

	//funciones anonimas como argumentos de otras funciones

	//Usar funcion anonima sin asignar a una variable

	fmt.Println("La suma es:", func(x, y int) int {
		return x + y
	}(5, 3))


//las funciones son de primer orden, es decir, se pueden asignar a variables, pasarlas como argumentos y devolverlas como resultado
//para esto son muy utiles las funcinoes anonimas

//funciones como valores

//funciones retornando otras funciones

func multiplicacion(factor int) func(int) int {
	return func(valor int) int {
		return valor * factor
	}
}

//funciones anonimas asigfnadas a una variable
func main() {

	//usamos la funcinon creada anteriormente

	var_multiplicar := multiplicacion(2)

	fmt.Println("2x3:", var_multiplicar(3))

	//funciones como argumentos de otras funciones

}

//COUSERS

	// funcino que no usa closures

	counter := func() int {
		count := 0
		count++
		return count
	}

	fmt.Println(counter())
	fmt.Println(counter())

	//el clouseer va a recordar el valor de count

	// funcino que usa closures

	counter2 := func() func() int {
		count := 0
		return func() int {
			count++
			return count
		}
	}()
	fmt.Println(counter2())
	fmt.Println(counter2())
	fmt.Println(counter2())

	// el clouseer va a recordar el valor de count

RECURSION 

package main

import "fmt"

//CRECION DE FUNCIONES RECURSIVAS

func suma(n int) int {
	if n == 0 {
		return 0
	}
	return n + suma(n-1)
}

func main() {

	//recursion  es una tecnica de la programacion
	//donde una funcion se llama a si misma de forma directa o indirecta,
	//para resolver un problema, subdividiendolo en subproblemas mas pequeños

	//en GO se implementa definiendo una funcion que tiene una condicion base para
	//detener la recursion y una llamada recursiva para resolver el problema

	//codicion base: hasta cuando se puede llamar para no entrar en bucle infinito
	//llamada recursiva: se llama a la funcion dentro de si misma, con argumentos que cada ves que
	//se llamen van a se modificados

	//sumar un numero de 1 a n

	numero := 5
	resultado := suma(numero)
	fmt.Println("La suma de los numeros de 1 a", numero, "es:", resultado)

}

package main

import "fmt"

func main() {

	//los puntero permiten trabajar con la direccion de memoria de una
	//variable en lugar de su valor.
	// un puntero almacena la direccion de memoria de una variable
	//y permite acceder y modificar su valor directamente.
	//permite la modficacion de la variable desde diversos lugares del sistema
	//optimizan el uso de memoria al permitir compartir datos entre funciones

	//declaracion de punteros

	//declara una variable normal

	x := 10

	//declara un puntero a un int

	var puntero *int

	//asigna la direccion de memoria de x a puntero

	puntero = &x

	fmt.Println("Direccion de la memoria de x:", puntero)
	fmt.Println("Valor de x a traves del puntero:", *puntero)

}

package main

import "fmt"

//##Punteros y funciones

func modificarValor(ptr *int) {
	*ptr = 50
}

func main() {
	//declaracion de variables

	x := 10

	fmt.Println("Valor de x antes de la funcion:", x)

	//pasar la direccion de memoria de x a la funcion
	modificarValor(&x)

	fmt.Println("Valor de x despues de la funcion:", x)

}

##structs

package main

import "fmt"

type Book struct {
	title  string
	author string
	year   int
	pages  int
	price  float64
}

func main() {

	//structs
	/*
		type NombreStruct struct {
			campo1 tipo1
			campo2 tipo2
		}
	*/

	//declaracion de variables

	//CREAR VARIABLES DE TIPO STRUCT BOOK

	myBook := Book{
		title:  "The Go Programming Language",
		author: "Alan A. A. Donovan",
		year:   2016,
		pages:  432,
		price:  59.99,
	}

	fmt.Println("Libro:", myBook.title)
	fmt.Println("Autor:", myBook.author)
	fmt.Println("Año:", myBook.year)
	fmt.Println("Paginas:", myBook.pages)
	fmt.Println("Precio:", myBook.price)

}

package main

import "fmt"

//definicion de la estructura
type Book struct {
	title  string
	author string
	year   int
	pages  int
	price  float64
}

//metodo asociado a la estructura Book pra mostrar detalles del libro

func (b Book) DisplayInfo() {
	fmt.Println("Detalles del libro:")
	fmt.Println("--------------------------------")
	fmt.Printf("Titulo: %s\n", b.title)
	fmt.Printf("Autor: %s\n", b.author)
	fmt.Printf("Año: %d\n", b.year)
	fmt.Printf("Paginas: %d\n", b.pages)
	fmt.Printf("Precio: %.2f\n", b.price)
}

// Metodo asociado para aplicar descuentos al precio del libro

func (b *Book) AplicarDescuento(descuento float64) {
	b.price = b.price - descuento
}

func main() {

	/* estructura de los metodos con receptores
	//sintaxis revicer

	func(revicer TipoDelReciver) nombreDelMetodo(parametros) (tipoDeRetorno) {
		//codigo del metodo
	}
	//Hay distintos tipos de receptores:
	// los por valor: el metodo trabaja con una copia del valor del receptor
	// los por puntero: el metodo trabaja con el valor original
	*/

	//creamos su instancia

	myBook := Book{
		title:  "El secreto de la felicidad",
		author: "Juan Perez",
		year:   2024,
		pages:  300,
		price:  25.99,
	}

	myBook.DisplayInfo()

	myBook.AplicarDescuento(10)

	myBook.DisplayInfo() // DESCUENTO APLICADO DE 10 PESOS

	/*
		Usamos receptores por valor cuando:
		- si el metodo no necesita modificar el valor del receptor, como el displayinfo
		- si el recepro no contiene muchos datos
		Usamos receptores por puntero cuando:
		- si el metodo necesita modificar el valor del receptor
		- si el receptor es una estructura grande o compleja
	*/
}

##EMBBEDING##
package main

import "fmt"

type Empleado struct {
	Nombre   string
	Apellido string
	Edad     int
	Email    string
}

func (e Empleado) MostrarDetalles() {
	fmt.Printf("Nombre: %s\n", e.Nombre)
	fmt.Printf("Apellido: %s\n", e.Apellido)
	fmt.Printf("Edad: %d\n", e.Edad)
	fmt.Printf("Email: %s\n", e.Email)
}

type Gerente struct {
	Empleado
	Departamento string
}

func (g Gerente) MostrarDetallesGerente() {
	g.MostrarDetalles()
	fmt.Printf("Departamento: %s\n", g.Departamento)
}

func main() {
	emp := Empleado{
		Nombre:   "Juan",
		Apellido: "Perez",
		Edad:     30,
		Email:    "juan.perez@example.com",
	}

	ger := Gerente{
		Empleado: Empleado{
			Nombre:   "Ana",
			Apellido: "Gomez",
			Edad:     53,
			Email:    "ANA.GOMEZ@example.com",
		},
		Departamento: "IT",
	}
	emp.MostrarDetalles()
	ger.MostrarDetallesGerente()
}

/*
	Embedding sintaxis:

	type EstruturaA struct {
		campo1 string
		campo2 int
	}

	type EstruturaB struct {
		EstruturaA
		campo3
	}




##INTERFACES##


*/